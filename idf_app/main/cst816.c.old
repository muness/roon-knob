#include "cst816.h"

#include "driver/i2c_master.h"
#include "esp_err.h"
#include "esp_log.h"

#include <string.h>

static const char *TAG = "cst816";

// Hardware configuration
#define CST816_I2C_PORT        I2C_NUM_0
#define CST816_I2C_ADDR        0x15
#define CST816_I2C_SDA_GPIO    11
#define CST816_I2C_SCL_GPIO    12
#define CST816_I2C_FREQ_HZ     300000  // 300 kHz

// I2C timeout
#define I2C_TIMEOUT_MS         1000

// CST816 register addresses
#define CST816_REG_STATUS      0x00
#define CST816_REG_TOUCH_NUM   0x02
#define CST816_REG_XPOS_H      0x03
#define CST816_REG_XPOS_L      0x04
#define CST816_REG_YPOS_H      0x05
#define CST816_REG_YPOS_L      0x06

static bool s_initialized = false;
static i2c_master_bus_handle_t s_bus_handle = NULL;
static i2c_master_dev_handle_t s_dev_handle = NULL;

/**
 * @brief Write data to CST816 register
 */
static esp_err_t cst816_i2c_write(uint8_t reg, uint8_t *data, uint8_t len) {
    if (!s_dev_handle) {
        return ESP_ERR_INVALID_STATE;
    }

    uint8_t *write_buf = (uint8_t *)malloc(len + 1);
    if (!write_buf) {
        return ESP_ERR_NO_MEM;
    }

    write_buf[0] = reg;
    memcpy(write_buf + 1, data, len);

    esp_err_t ret = i2c_master_transmit(
        s_dev_handle,
        write_buf,
        len + 1,
        I2C_TIMEOUT_MS
    );

    free(write_buf);
    return ret;
}

/**
 * @brief Read data from CST816 register
 */
static esp_err_t cst816_i2c_read(uint8_t reg, uint8_t *data, uint8_t len) {
    if (!s_dev_handle) {
        return ESP_ERR_INVALID_STATE;
    }

    return i2c_master_transmit_receive(
        s_dev_handle,
        &reg,
        1,
        data,
        len,
        I2C_TIMEOUT_MS
    );
}

bool cst816_init(void) {
    ESP_LOGI(TAG, "Initializing CST816 touch controller");
    ESP_LOGI(TAG, "  I2C Port: %d", CST816_I2C_PORT);
    ESP_LOGI(TAG, "  SDA GPIO: %d", CST816_I2C_SDA_GPIO);
    ESP_LOGI(TAG, "  SCL GPIO: %d", CST816_I2C_SCL_GPIO);
    ESP_LOGI(TAG, "  I2C Addr: 0x%02x", CST816_I2C_ADDR);
    ESP_LOGI(TAG, "  Clock: %d Hz", CST816_I2C_FREQ_HZ);

    // Configure I2C master bus
    i2c_master_bus_config_t bus_config = {
        .i2c_port = CST816_I2C_PORT,
        .sda_io_num = CST816_I2C_SDA_GPIO,
        .scl_io_num = CST816_I2C_SCL_GPIO,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .intr_priority = 0,
        .trans_queue_depth = 0,
        .flags.enable_internal_pullup = true,
    };

    ESP_LOGI(TAG, "Creating I2C master bus...");
    esp_err_t ret = i2c_new_master_bus(&bus_config, &s_bus_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "I2C master bus creation failed: %s", esp_err_to_name(ret));
        return false;
    }
    ESP_LOGI(TAG, "I2C master bus created successfully");

    // Configure CST816 device on the bus
    i2c_device_config_t dev_config = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = CST816_I2C_ADDR,
        .scl_speed_hz = CST816_I2C_FREQ_HZ,
    };

    ESP_LOGI(TAG, "Adding CST816 device to I2C bus...");
    ret = i2c_master_bus_add_device(s_bus_handle, &dev_config, &s_dev_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to add CST816 device to I2C bus: %s", esp_err_to_name(ret));
        i2c_del_master_bus(s_bus_handle);
        s_bus_handle = NULL;
        return false;
    }
    ESP_LOGI(TAG, "CST816 device added to I2C bus");

    // Switch CST816 to normal mode (wake up from sleep)
    ESP_LOGI(TAG, "Waking up CST816 from sleep...");
    uint8_t mode = 0x00;
    ret = cst816_i2c_write(CST816_REG_STATUS, &mode, 1);
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "Failed to write wake command to CST816: %s", esp_err_to_name(ret));
        // Don't fail here - some devices may not respond to this command
    } else {
        ESP_LOGI(TAG, "Wake command sent successfully");
    }

    // Test read to verify communication
    ESP_LOGI(TAG, "Testing CST816 communication...");
    uint8_t test_data[7] = {0};
    ret = cst816_i2c_read(CST816_REG_STATUS, test_data, 7);
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "Initial read test failed: %s (may be normal if no touch)", esp_err_to_name(ret));
    } else {
        ESP_LOGI(TAG, "Communication test successful, data: %02x %02x %02x %02x %02x %02x %02x",
                 test_data[0], test_data[1], test_data[2], test_data[3],
                 test_data[4], test_data[5], test_data[6]);
    }

    s_initialized = true;
    ESP_LOGI(TAG, "CST816 initialized successfully");
    return true;
}

bool cst816_get_touch(uint16_t *x, uint16_t *y) {
    if (!s_initialized) {
        ESP_LOGW(TAG, "CST816 not initialized");
        return false;
    }

    if (!x || !y) {
        return false;
    }

    // Read 7 bytes starting from register 0x00
    // [0] = status
    // [1] = gesture
    // [2] = touch count
    // [3] = X high byte
    // [4] = X low byte
    // [5] = Y high byte
    // [6] = Y low byte
    uint8_t data[7] = {0};
    esp_err_t ret = cst816_i2c_read(CST816_REG_STATUS, data, 7);
    if (ret != ESP_OK) {
        // Don't log every read failure - too noisy
        return false;
    }

    uint8_t touch_count = data[2];
    if (touch_count == 0) {
        return false;  // No touch detected
    }

    // Extract coordinates (12-bit values)
    *x = ((uint16_t)(data[3] & 0x0F) << 8) | (uint16_t)data[4];
    *y = ((uint16_t)(data[5] & 0x0F) << 8) | (uint16_t)data[6];

    return true;
}
